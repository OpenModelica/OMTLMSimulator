#include <cassert>

// For repetive division it can be more efficient to create a intermediate variable
// and to do multiplication instead. Some low level tests indicate a factor 4.
// On other hand, we loose some precision. Which is most important, tests will tell.
// To activate, define these. DF 2011-04-04
#define FASTDIV          // Was activated in the past.
//#define FASTDIVX       // Was not activated in the past. 
	                 // Tried 2011-04-13, was a bit slower on test cases! Needs more investigation. DF


////////////////////////////////////////////////////////////////////////////////
//
// Definitions of member functions and global methods to class double3
//

inline double3::double3(const double val)
: XX(val), YY(val), ZZ(val)
{}

inline double3::double3(const double xval, 
			const double yval, 
			const double zval) 
: XX(xval), YY(yval), ZZ(zval)
{}

inline double3::double3(const double3& val)
: XX(val.XX), YY(val.YY), ZZ(val.ZZ)
{}

inline double double3::norm2() const
{
    return sqrt(XX * XX + YY * YY + ZZ * ZZ);
}


inline double3& double3::normalize() 
{
    double mag = this->norm2();
    if (mag != 0.0) {
#ifdef FASTDIV
	mag = 1.0 / mag;
	XX *= mag;
	YY *= mag;
	ZZ *= mag;
#else
	XX /= mag;
	YY /= mag;
	ZZ /= mag;
#endif
    } 

    return *this;
}

inline double3& double3::normalizeSafe() 
{
    double mag = this->norm2();
    if (mag != 0.0) {
#ifdef FASTDIV
	mag = 1.0 / mag;
	XX *= mag;
	YY *= mag;
	ZZ *= mag;
#else
	XX /= mag;
	YY /= mag;
	ZZ /= mag;
#endif
    } else {
	XX = 1.0;
	YY = 0.0;
	ZZ = 0.0;
    }	

    return *this;
}

inline double& double3::operator()(const int i)
{
    double *x;	
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif

    switch(i) {
    case 1:
      x = &XX;
      break;	
    case 2:
      x = &YY;
      break;
    default:
      x = &ZZ;
      break;
    }

//    if (i==1) x = &XX;
//    else if (i==2) x = &YY;
//    else x = &ZZ;

    return *x; 
}


inline double double3::operator()(const int i) const
{
    double x;
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif
    switch(i) {
    case 1:
      x = XX;
      break;	
    case 2:
      x = YY;
      break;
    default:
      x = ZZ;
      break;
    }

//    if (i==1) x = XX;
//    else if (i==2) x = YY;
//    else x = ZZ;

    return x; 
}

inline double3& double3::operator=(const double a) 
{
    XX = a;
    YY = a;
    ZZ = a;
    return *this;
}

inline double3& double3::operator=(const double3& v) 
{
    if (this != &v) {	
       XX = v.XX;
       YY = v.YY;
       ZZ = v.ZZ;
    }
    return *this;
}

inline double3& double3::operator+=(const double3& v) 
{
    XX += v.XX;
    YY += v.YY;
    ZZ += v.ZZ;
    return *this;
}

inline double3& double3::operator-=(const double3& v) 
{
    XX -= v.XX;
    YY -= v.YY;
    ZZ -= v.ZZ;
    return *this;
}

inline double3& double3::operator*=(const double s) 
{
    XX *= s;
    YY *= s;
    ZZ *= s;
    return *this;
}

inline double3& double3::operator/=(const double s) 
{
#ifdef FASTDIVX
    double tmp = 1.0 / s;
    XX *= tmp;
    YY *= tmp;
    ZZ *= tmp;
#else
    XX /= s;
    YY /= s;
    ZZ /= s;
#endif
    return *this;
}




inline void double3::Set(const double a1, const double a2, const double a3) 
{
    XX = a1;
    YY = a2;
    ZZ = a3;
}


inline void double3::Get(double& a1, double& a2, double& a3) const
{
    a1 = XX;
    a2 = YY;
    a3 = ZZ;
}




////////////////////////////////////////////////////////////////////////////////
//
// Definition of double33 member functions
//


inline double33::double33(const double val)
{
    x[0] = val; x[1] = val; x[2] = val;
    x[3] = val; x[4] = val; x[5] = val;
    x[6] = val; x[7] = val; x[8] = val;
}



inline double& double33::operator()(const int row, const int col) 
{
#ifdef DEBUGFLG
    assert(row>=1 && row<=3);
    assert(col>=1 && col<=3);
#endif
    return x[(row-1)*3+(col-1)];
}

inline double double33::operator()(const int row, const int col) const
{
#ifdef DEBUGFLG
    assert(row>=1 && row<=3);	
    assert(col>=1 && col<=3);	
#endif
    return x[(row-1)*3+(col-1)];
}


inline const double3 double33::operator()(const int row) const
{
#ifdef DEBUGFLG
    assert(row>=1 && row<=3);	
#endif
    return double3(x[(row-1)*3], x[(row-1)*3+1], x[(row-1)*3+2]);
}


inline double33& double33::operator=(const double a)
{
    x[0] = a; x[1] = a; x[2] = a;
    x[3] = a; x[4] = a; x[5] = a;
    x[6] = a; x[7] = a; x[8] = a;
    return *this;
}



// New stuff

inline double33& double33::operator+=(const double33& b)
{
    x[0] += b.x[0];
    x[1] += b.x[1];
    x[2] += b.x[2];
    x[3] += b.x[3];
    x[4] += b.x[4];
    x[5] += b.x[5];
    x[6] += b.x[6];
    x[7] += b.x[7];
    x[8] += b.x[8];

    return *this;
}



inline double33& double33::operator+=(const double s)
{
    x[0] += s;
    x[1] += s;
    x[2] += s;
    x[3] += s;
    x[4] += s;
    x[5] += s;
    x[6] += s;
    x[7] += s;
    x[8] += s;

    return *this;
}

inline double33& double33::operator-=(const double33& b)
{
    x[0] -= b.x[0];
    x[1] -= b.x[1];
    x[2] -= b.x[2];
    x[3] -= b.x[3];
    x[4] -= b.x[4];
    x[5] -= b.x[5];
    x[6] -= b.x[6];
    x[7] -= b.x[7];
    x[8] -= b.x[8];

    return *this;
}

inline double33& double33::operator-=(const double s)
{
    x[0] -= s;
    x[1] -= s;
    x[2] -= s;
    x[3] -= s;
    x[4] -= s;
    x[5] -= s;
    x[6] -= s;
    x[7] -= s;
    x[8] -= s;

    return *this;
}


inline double33& double33::operator*=(const double s)
{
    x[0] *= s;
    x[1] *= s;
    x[2] *= s;
    x[3] *= s;
    x[4] *= s;
    x[5] *= s;
    x[6] *= s;
    x[7] *= s;
    x[8] *= s;

    return *this;
}



inline double33& double33::operator/=(const double s)
{
#ifdef FASTDIVX
    double tmp = 1.0 / s;	
    x[0] *= tmp;
    x[1] *= tmp;
    x[2] *= tmp;
    x[3] *= tmp;
    x[4] *= tmp;
    x[5] *= tmp;
    x[6] *= tmp;
    x[7] *= tmp;
    x[8] *= tmp;
#else
    x[0] /= s;
    x[1] /= s;
    x[2] /= s;
    x[3] /= s;
    x[4] /= s;
    x[5] /= s;
    x[6] /= s;
    x[7] /= s;
    x[8] /= s;
#endif

    return *this;
}


inline void double33::SetRows(const double3& r1,
                       const double3& r2,
                       const double3& r3)
{
    x[0] = r1.XX; x[1] = r1.YY; x[2] = r1.ZZ;
    x[3] = r2.XX; x[4] = r2.YY; x[5] = r2.ZZ;
    x[6] = r3.XX; x[7] = r3.YY; x[8] = r3.ZZ;
}

inline void double33::Set(const double3& a1, const double3& a2, const double3& a3)
{
    SetRows(a1,a2,a3);
}

inline void double33::SetCols(const double3& c1,
                       const double3& c2,
                       const double3& c3)
{
    x[0] = c1(1); x[1] = c2(1); x[2] = c3(1);
    x[3] = c1(2); x[4] = c2(2); x[5] = c3(2);
    x[6] = c1(3); x[7] = c2(3); x[8] = c3(3);
}

inline double double33::det() const 
{
    return(x[0]*(x[4]*x[8] - x[5]*x[7]) +
           x[1]*(x[5]*x[6] - x[3]*x[8]) +
           x[2]*(x[3]*x[7] - x[4]*x[6])  );
}


inline const double33 double33::T() const
{
    
    return double33(x[0], x[3], x[6],
                       x[1], x[4], x[7],
                       x[2], x[5], x[8]);
}


////////////////////////////////////////////////////////////////////////
//
// Definition of global functions related to double3
//

// -V 
inline const double3 operator-(const double3& v)
{
    return double3(-v.XX, -v.YY, -v.ZZ);
}

// s * V 
inline const double3 operator*(const double s, const double3& v)
{
    return double3(s * v.XX, s * v.YY, s * v.ZZ);
}

// V * s 
inline const double3 operator*(const double3& v, const double s) 
{
    return double3(s * v.XX, s * v.YY, s * v.ZZ);
}


// V * V
inline double operator*(const double3& a, const double3& b)
{
    return (a.XX*b.XX + a.YY*b.YY + a.ZZ*b.ZZ);
}	


// V / s 
inline const double3 operator/(const double3& v, const double s)
{
#ifdef FASTDIV
    double recip = 1.0 / s;
    return double3(v.XX * recip, v.YY * recip, v.ZZ * recip);
#else
    return double3(v.XX / s, v.YY / s, v.ZZ / s);
#endif
}


// V / V 
inline const double3 operator/(const double3& v, const double3& w)
{
    return double3(v.XX / w.XX, v.YY / w.YY, v.ZZ / w.ZZ);
}

// V + V 
inline const double3 operator+(const double3& a, const double3& b)
{
    return double3(a.XX + b.XX, a.YY + b.YY, a.ZZ + b.ZZ);
}

// V + s 
inline const double3 operator+(const double3& a, const double s)
{
    return double3(a.XX + s, a.YY + s, a.ZZ + s);
}

// s + V 
inline const double3 operator+(const double s, const double3& a)
{
    return double3(a.XX + s, a.YY + s, a.ZZ + s);
}

// V - V
inline const double3 operator-(const double3& a, const double3& b)
{
    return double3(a.XX - b.XX, a.YY - b.YY, a.ZZ - b.ZZ);
}

// V - s 
inline const double3 operator-(const double3& a, const double s)
{
    return double3(a.XX - s, a.YY - s, a.ZZ - s);
}

// s - V 
inline const double3 operator-(const double s, const double3& a)
{
    return double3(s - a.XX, s - a.YY, s - a.ZZ);
}

// V == V (no fuzz for comparison) 
inline bool operator==(const double3& a, const double3& b)
{
    return a.XX == b.XX && a.YY == b.YY && a.ZZ == b.ZZ;
}

// V == s (no fuzz for comparison) 
inline bool operator==(const double3& a, const double b)
{
    return a.XX == b && a.YY == b && a.ZZ == b;
}

// s == V (no fuzz for comparison) 
inline bool operator==(const double a, const double3& b)
{
    return a == b.XX && a == b.YY && a == b.ZZ;
}

// V != V (no fuzz for comparison) 
inline bool operator!=(const double3& a, const double3& b) 
{
    return !(a == b);
}


// V = Cross(V1, V2) CrossProduct, normally written V = V1 x V2
inline const double3 Cross(const double3& V1, const double3& V2)
{
    return double3(V1.YY*V2.ZZ - V2.YY*V1.ZZ,
		      V1.ZZ*V2.XX - V2.ZZ*V1.XX,
		      V1.XX*V2.YY - V2.XX*V1.YY);
}



inline const double3 sin(const double3& v)
{
    return double3(sin(v.XX), sin(v.YY), sin(v.ZZ));
}

inline const double3 cos(const double3& v)
{
    return double3(cos(v.XX), cos(v.YY), cos(v.ZZ));
}



////////////////////////////////////////////////////////////////////////
//
// Definition of global double33 related functions
//

// -M
inline const double33 operator-(const double33& m)
{
    return double33(-m.x[0], -m.x[1], -m.x[2],
		       -m.x[3], -m.x[4], -m.x[5],
		       -m.x[6], -m.x[7], -m.x[8]);
}

// s * M
inline const double33 operator*(const double s, const double33& m)
{
    return double33(s * m.x[0], s * m.x[1], s * m.x[2],
		       s * m.x[3], s * m.x[4], s * m.x[5],
		       s * m.x[6], s * m.x[7], s * m.x[8]);
}

// M * s 
inline const double33 operator*(const double33& m, const double s) 
{
    return double33(s * m.x[0], s * m.x[1], s * m.x[2],
		       s * m.x[3], s * m.x[4], s * m.x[5],
		       s * m.x[6], s * m.x[7], s * m.x[8]);
}

// M * M
inline const double33 operator*(const double33& a, const double33& b)
{
#if 0
    // This old implementation had problem with inlining for SUN C++.
    return double33(a.x[0]*b.x[0] + a.x[1]*b.x[3] + a.x[2]*b.x[6],
 		       a.x[0]*b.x[1] + a.x[1]*b.x[4] + a.x[2]*b.x[7],
 		       a.x[0]*b.x[2] + a.x[1]*b.x[5] + a.x[2]*b.x[8],
 		       a.x[3]*b.x[0] + a.x[4]*b.x[3] + a.x[5]*b.x[6],
 		       a.x[3]*b.x[1] + a.x[4]*b.x[4] + a.x[5]*b.x[7],
 		       a.x[3]*b.x[2] + a.x[4]*b.x[5] + a.x[5]*b.x[8],
 		       a.x[6]*b.x[0] + a.x[7]*b.x[3] + a.x[8]*b.x[6],
 		       a.x[6]*b.x[1] + a.x[7]*b.x[4] + a.x[8]*b.x[7],
 		       a.x[6]*b.x[2] + a.x[7]*b.x[5] + a.x[8]*b.x[8]);
#endif
    double33 c; // Stop Chaperon complaints.
    c.x[0] = a.x[0]*b.x[0] + a.x[1]*b.x[3] + a.x[2]*b.x[6];
    c.x[1] = a.x[0]*b.x[1] + a.x[1]*b.x[4] + a.x[2]*b.x[7];
    c.x[2] = a.x[0]*b.x[2] + a.x[1]*b.x[5] + a.x[2]*b.x[8];
    c.x[3] = a.x[3]*b.x[0] + a.x[4]*b.x[3] + a.x[5]*b.x[6];
    c.x[4] = a.x[3]*b.x[1] + a.x[4]*b.x[4] + a.x[5]*b.x[7];
    c.x[5] = a.x[3]*b.x[2] + a.x[4]*b.x[5] + a.x[5]*b.x[8];
    c.x[6] = a.x[6]*b.x[0] + a.x[7]*b.x[3] + a.x[8]*b.x[6];
    c.x[7] = a.x[6]*b.x[1] + a.x[7]*b.x[4] + a.x[8]*b.x[7];
    c.x[8] = a.x[6]*b.x[2] + a.x[7]*b.x[5] + a.x[8]*b.x[8];

    return c;
}	

// M / s 
inline const double33 operator/(const double33& m, const double s)
{
#ifdef FASTDIV
    double recip = 1.0 / s;
    return double33(m.x[0] * recip, m.x[1] * recip, m.x[2] * recip,
                    m.x[3] * recip, m.x[4] * recip, m.x[5] * recip,
                    m.x[6] * recip, m.x[7] * recip, m.x[8] * recip);
#else
    return double33(m.x[0] / s, m.x[1] / s, m.x[2] / s,
		    m.x[3] / s, m.x[4] / s, m.x[5] / s,
                    m.x[6] / s, m.x[7] / s, m.x[8] / s);
#endif
}

// M + M 
inline const double33 operator+(const double33& a, const double33& b)
{
    return double33(a.x[0] + b.x[0], a.x[1] + b.x[1], a.x[2] + b.x[2],
		       a.x[3] + b.x[3], a.x[4] + b.x[4], a.x[5] + b.x[5],
		       a.x[6] + b.x[6], a.x[7] + b.x[7], a.x[8] + b.x[8]);
}

// M + s 
inline const double33 operator+(const double33& m, const double s)
{
    return double33(m.x[0] + s, m.x[1] + s, m.x[2] + s,
		       m.x[3] + s, m.x[4] + s, m.x[5] + s,
		       m.x[6] + s, m.x[7] + s, m.x[8] + s);
}

// s + M
inline const double33 operator+(const double s, const double33& m)
{
    return double33(m.x[0] + s, m.x[1] + s, m.x[2] + s,
		       m.x[3] + s, m.x[4] + s, m.x[5] + s,
		       m.x[6] + s, m.x[7] + s, m.x[8] + s);
}

// M - M 
inline const double33 operator-(const double33& a, const double33& b)
{
    return double33(a.x[0] - b.x[0], a.x[1] - b.x[1], a.x[2] - b.x[2],
		       a.x[3] - b.x[3], a.x[4] - b.x[4], a.x[5] - b.x[5],
		       a.x[6] - b.x[6], a.x[7] - b.x[7], a.x[8] - b.x[8]);
}

// M - s 
inline const double33 operator-(const double33& m, const double s)
{
    return double33(m.x[0] - s, m.x[1] - s, m.x[2] - s,
		       m.x[3] - s, m.x[4] - s, m.x[5] - s,
		       m.x[6] - s, m.x[7] - s, m.x[8] - s);
}

// s - M
inline const double33 operator-(const double s, const double33& m)
{
    return double33(s - m.x[0], s - m.x[1], s - m.x[2],
		       s - m.x[3], s - m.x[4], s - m.x[5],
		       s - m.x[6], s - m.x[7], s - m.x[8]);
}

// M == M (no fuzz for comparison) 
inline bool operator==(const double33& a, const double33& b)
{
    return (a.x[0] == b.x[0] && a.x[1] == b.x[1] && a.x[2] == b.x[2] &&
	    a.x[3] == b.x[3] && a.x[4] == b.x[4] && a.x[5] == b.x[5] &&
	    a.x[6] == b.x[6] && a.x[7] == b.x[7] && a.x[8] == b.x[8]);
}


// M == s (no fuzz for comparison) 
inline bool operator==(const double33& a, const double b)
{
    return (a.x[0] == b && a.x[1] == b && a.x[2] == b &&
	    a.x[3] == b && a.x[4] == b && a.x[5] == b &&
	    a.x[6] == b && a.x[7] == b && a.x[8] == b);
}

// s == M (no fuzz for comparison) 
inline bool operator==(const double a, const double33& b)
{
    return (a == b.x[0] && a == b.x[1] && a == b.x[2] &&
	    a == b.x[3] && a == b.x[4] && a == b.x[5] &&
	    a == b.x[6] && a == b.x[7] && a == b.x[8]);
}

// M != M (no fuzz for comparison) 
inline bool operator!=(const double33& a, const double33& b) 
{
    return !(a == b);
}


inline const double33 OuterProduct(const double3& a, const double3& b)
{
    return double33(a.XX*b.XX, a.XX*b.YY, a.XX*b.ZZ,
		       a.YY*b.XX, a.YY*b.YY, a.YY*b.ZZ,
		       a.ZZ*b.XX, a.ZZ*b.YY, a.ZZ*b.ZZ);
}	


// inline const double33 Transpose(const double33& a)
// {
    
//     return double33(a.x[0], a.x[3], a.x[6],
//                        a.x[1], a.x[4], a.x[7],
//                        a.x[2], a.x[5], a.x[8]);
// }




///////////////////////////////////////////////////////////////////////
//
// Definitions of functions used for coordinate transformations etc.
//


// Create a symmetric matrix 
inline const double33 Asym(const double axx, 
			   const double axy, 
			   const double axz,
			   const double ayy, 
			   const double ayz, 
			   const double azz) 
{ 
    return double33(axx,axy,axz,
		    axy,ayy,ayz,
		    axz,ayz,azz);
}


inline const double33 Acyl(const double& RC_2) 
{ 
    double tmpc = cos(RC_2);
    double tmps = sin(RC_2);

    // Transformation matrix from system cBase to system this system.
    // We use cylindrical rotation.
    
    return double33(tmpc, tmps, 0.0,
		    -tmps, tmpc, 0.0,
		    0.0, 0.0, 1.0);
}

inline const double33 Acyl(const double3& RC) 
{ 
    double tmpc = cos(RC.YY);
    double tmps = sin(RC.YY);

    // Transformation matrix from system cBase to system this system.
    // We use cylindrical rotation.
    
    return double33(tmpc, tmps, 0.0,
                       -tmps, tmpc, 0.0,
                       0.0, 0.0, 1.0);
}


inline const double3 RC2R(const double3& RC) 
{
    return double3(cos(RC.YY)*RC.XX, sin(RC.YY)*RC.XX, RC.ZZ);
}


inline const double3 vRC2vR(const double3& RC,
			    const double3& vRC) 
{
    double tmpc = cos(RC.YY);
    double tmps = sin(RC.YY);

    return double3(tmpc*vRC.XX - tmps*RC.XX*vRC.YY,
                      tmps*vRC.XX + tmpc*RC.XX*vRC.YY,
                      vRC.ZZ);
}

inline const double3 R2RC(const double3& R) 
{
    return double3(sqrt(R.XX*R.XX + R.YY*R.YY), atan2(R.YY, R.XX), R.ZZ);
}


inline int sizeOf(const double3 &)
{
    return 3*sizeof(double) ;
}

inline int sizeOf(const double33 &)
{
    return 9*sizeof(double) ;
}



inline void TFMc1toc2(const double3& F_In,
		      const double3& M_c1_In,
		      const double3& c2_R_c1_In,
		      double3& M_c2_Out)
{
    M_c2_Out = M_c1_In - Cross(c2_R_c1_In, F_In);
}


inline void TFMc1toc2(const double3& F_c1_In,
		      const double3& M_c1_c1_In,
		      const double3& c2_R_c1_c1_In,
		      const double33& c2_A_c1_In,
		      double3& F_c2_Out,
		      double3& M_c2_c2_Out)
{
    F_c2_Out = c2_A_c1_In*F_c1_In;
    M_c2_c2_Out = c2_A_c1_In*(M_c1_c1_In - Cross(c2_R_c1_c1_In, F_c1_In));
}



inline void TFMc2toc1(const double3& F_In,
		      const double3& M_c2_In,
		      const double3& c2_R_c1_In,
		      double3& M_c1_Out)
{
    M_c1_Out = M_c2_In + Cross(c2_R_c1_In, F_In);
}


inline void TFMc2toc1(const double3& F_c2_In,
		      const double3& M_c2_c2_In,
		      const double3& c2_R_c1_c1_In,
		      const double33& c2_A_c1_In,
		      double3& F_c1_Out,
		      double3& M_c1_c1_Out)
{
    double33 c1_A_c2_tmp = c2_A_c1_In.T();
    F_c1_Out = c1_A_c2_tmp*F_c2_In;
    M_c1_c1_Out = c1_A_c2_tmp*M_c2_c2_In + Cross(c2_R_c1_c1_In, F_c1_Out);
}


//! Create a skew symmetric matrix. That is Cross(v, x) = Skew(v)*x;
//! This function logically belongs to lightmat.
inline void MakeSkewMatrix(const double3& v, double33& m)
{
    m(1,1) = 0;
    m(2,2) = 0;
    m(3,3) = 0;
    register double tmp;
    tmp = v(1);
    m(3, 2) = tmp;
    m(2, 3) = -tmp;
    tmp = v(2);
    m(1, 3) = tmp;
    m(3, 1) = -tmp;
    tmp = v(3);
    m(2, 1) = tmp;
    m(1, 2) = -tmp;
}







// Inline definitions for float3

inline float float3::operator()(const int i) const
{
    float x;
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif
    switch(i) {
    case 1:
      x = XX;
      break;	
    case 2:
      x = YY;
      break;
    default:
      x = ZZ;
      break;
    }

    return x; 
}


inline float& float3::operator()(const int i)
{
    float *x;	
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif

    switch(i) {
    case 1:
      x = &XX;
      break;	
    case 2:
      x = &YY;
      break;
    default:
      x = &ZZ;
      break;
    }

//    if (i==1) x = &XX;
//    else if (i==2) x = &YY;
//    else x = &ZZ;

    return *x; 
}


// Inline definitions for intN

inline int& intN::operator()(const int i)
{
#ifdef DEBUGFLG
    assert(i>0 && i<=len);
#endif
    return (data[i-1]);
}


inline int intN::operator()(const int i) const
{
#ifdef DEBUGFLG
    assert(i>0 && i<=len);
#endif
    return (data[i-1]);
}

inline int intN::length() const
{
    return len;
}



// Inline definitions for doubleN

inline double& doubleN::operator()(const int i)
{
#ifdef DEBUGFLG
    assert(i>0 && i<=len);
#endif
    return (data[i-1]);
}

inline double doubleN::operator()(const int i) const
{
#ifdef DEBUGFLG
    assert(i>0 && i<=len);
#endif
    return (data[i-1]);
}

inline int doubleN::length() const
{
    return len;
}



// Inline definitions for doubleN3

inline double3& doubleN3::operator()(const int i1)
{
#ifdef DEBUGFLG
    assert(i1>0 && i1<=len);
#endif
    return (data[i1-1]);
}

inline const double3& doubleN3::operator()(const int i1) const
{
#ifdef DEBUGFLG
    assert(i1>0 && i1<=len);
#endif
    return (data[i1-1]);
}

#if 0 
//! Deactivated since not used and not most efficient. DF 2006-03-09
inline double& doubleN3::operator()(const int i1, const int i2)
{
#ifdef DEBUGFLG
    assert(i2>0 && i2<=3);
    assert(i1>0 && i1<=len);
#endif
    return ( data[i1-1](i2) );
}

//! Deactivated since not used and not most efficient. DF 2006-03-09
inline const double doubleN3::operator()(const int i1, const int i2) const
{
#ifdef DEBUGFLG
    assert(i2>0 && i2<=3);
    assert(i1>0 && i1<=len);
#endif
    return ( data[i1-1](i2) );
}
#endif

// inline void doubleN3::Pack(const PackType pdir, aPackBuf& bp) 
// {
//     if (pdir==Down) {
//         bp << len ;
//     } else {
//         int len_tmp ;
//         bp >> len_tmp ;    
//         assert(len==len_tmp);
//     }

//     for(int i=1; i<=len; i++)
// 	data[i-1].Pack(pdir, bp) ;
// }

inline int doubleN3::length() const
{
    return len;
}





// Inline definitions for doubleN33

inline double33& doubleN33::operator()(const int i1)
{
#ifdef DEBUGFLG
    assert(i1>0 && i1<=len);
#endif
    return (data[i1-1]);
}

inline const double33& doubleN33::operator()(const int i1) const
{
#ifdef DEBUGFLG
    assert(i1>0 && i1<=len);
#endif
    return (data[i1-1]);
}

#if 0 
//! Deactivated since not used and not most efficient. DF 2006-03-09
inline const double3 doubleN33::operator()(const int i1, const int i2) const
{
#ifdef DEBUGFLG
    assert(i2>0 && i2<=3);
    assert(i1>0 && i1<=len);
#endif
    return ( data[i1-1](i2) );
}


//! Deactivated since not used and not most efficient. DF 2006-03-09
inline double& doubleN33::operator()(const int i1, const int i2, const int i3)
{
#ifdef DEBUGFLG
    assert(i3>0 && i3<=3);
    assert(i2>0 && i2<=3);
    assert(i1>0 && i1<=len);
#endif
    return ( data[i1-1](i2,i3) );
}


//! Deactivated since not used and not most efficient. DF 2006-03-09
inline const double doubleN33::operator()(const int i1, const int i2, const int i3) const
{
#ifdef DEBUGFLG
    assert(i3>0 && i3<=3);
    assert(i2>0 && i2<=3);
    assert(i1>0 && i1<=len);
#endif
    return ( data[i1-1](i2,i3) );
}
#endif

inline int doubleN33::length() const
{
    return len;
}
#ifdef USE_IMPLICIT_CONV
inline double3::double3  (const float3& conv_in){
        XX= conv_in.XX;
        YY= conv_in.YY;
        ZZ= conv_in.ZZ;
}
#endif

inline const float3 operator+(const float3& a, const float3& b){
    return float3(a.XX+b.XX,a.YY+b.YY,a.ZZ+b.ZZ);
}

inline const float3 operator-(const float3& a, const float3& b){
    return float3(a.XX-b.XX,a.YY-b.YY,a.ZZ-b.ZZ);
}

inline bool operator==(const float3& a, const float3& b) {
    return (a.XX == b.XX) && (a.YY == b.YY) && (a.ZZ == b.ZZ);
}

//! M != M (no fuzz for comparison) 
inline bool operator!=(const float3& a, const float3& b) {
    return !(a==b);
}

inline float3& float3::operator=(const float3& m) {
    XX = m.XX;
    YY = m.YY;
    ZZ = m.ZZ;
    return (*this);
}

//! Conversion to string.
Bstring ToStr(const float3& val);

inline float3& float3::operator+=(const float3& m) {
    XX += m.XX;
    YY += m.YY;
    ZZ += m.ZZ;
    return (*this);
}

inline float3& float3::operator-=(const float3& m) {
    XX += m.XX;
    YY += m.YY;
    ZZ += m.ZZ;
    return (*this);
}

inline float3::float3(const float a1, const float a2, const float a3):
    XX(a1),YY(a2),ZZ(a3){}

