\documentclass[11pt,a4paper]{report}
\usepackage{inputenc} 
\usepackage[english]{babel} 
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{cleveref}
\usepackage[section]{placeins}

%Remove trailing zero in section numbering
\renewcommand{\thesection}{\arabic{section}}

%\lstset{
%  basicstyle=\ttfamily,
%  keywordstyle=\textcolor{blue},
%  language=XML,
%  morekeywords={<ScalarVariable,Real}
%}

\renewcommand{\ttdefault}{pcr}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
  moredelim=[s][\bfseries\color{Maroon}]{</}{>},
  moredelim=[l][\bfseries\color{Maroon}]{/>},
  moredelim=[l][\bfseries\color{Maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{Maroon},
  stringstyle=\color{blue},
  identifierstyle=\color{red}
}

\begin{document}

\title{Wrapper for Functional Mock-up Interface in TLM-based Asynchronous Co-Simulation}
\author{Robert Braun}

\maketitle

\section{Introduction}
Functional Mock-up Interface (FMI) is a tool-independent standard for connecting simulation tools \cite{blochwitz2009}. 
One tool can export a model as a Functional Mockup Unit (FMU), a ZIP package with the file extension FMU. 
This file is in turn loaded by the master simulation tool, which can connect and simulate the model.
An FMU file contains a model description XML file called \texttt{modelDescription.xml}, binaries for different platforms and other optional content.
It is important that the FMU contains a binary file for the platform where the master simulation tool is executed.

There are two versions of the FMI standard: FMI for Co-Simulation and FMI for Model Exchange.
The main difference is that FMUs for Co-Simulation contain their own built-in solvers, and only exchange data at predefined communication points.
FMUs for Model Exchange require a solver in the master simulation tool.

Including FMUs in the TLM framework requires a wrapper.
\texttt{FMIWrapper} is a generic wrapper for connecting functional mockup units (FMUs) to the TLM framework.
It uses the FMI Library from Modelon \cite{modelon2015} to load an FMU, and the TLMPlugin for socket communication with the framework, see \cref{fig:overview}.

\begin{figure}[ht]
\begin{tikzpicture}
\def\dx{0.0495*\textwidth}

\node[rectangle,draw,thick, 
      minimum width=5*\dx, 
      minimum height=5*\dx, 
      text depth=5*\dx-20pt] () {FMIWrapper};

\node[rectangle, draw, thick, 
      minimum width=3*\dx, 
      minimum height=3*\dx, 
      xshift=2.5*\dx,
      fill=white] (tp1) {TLMPlugin};
      
\node[rectangle, draw, thick, 
      minimum width=3*\dx, 
      minimum height=3*\dx, 
      xshift=-2.5*\dx,
      fill=white] (fl) {FMILibrary};
      
\node[rectangle, draw, thick, 
      minimum width=3*\dx, 
      minimum height=3*\dx, 
      xshift=-7.5*\dx] (fmu) {xmodel.fmu};

\node[rectangle, draw, thick, 
      minimum width=3.5*\dx, 
      minimum height=5*\dx, 
      text depth=5*\dx-20pt,
      xshift=9.25*\dx,
      fill=white] () {TLMManager};

\node[rectangle, draw, thick, 
      minimum width=3*\dx, 
      minimum height=3*\dx, 
      xshift=7.5*\dx,
      fill=white] (tp2) {TLMPlugin};

\draw[thick,->,very thick] (fmu) edge[bend left] (fl);
\draw[thick,<-,very thick] (fmu) edge[bend right] (fl);
\draw[thick,->,very thick] (fl) edge[bend left] (tp1);
\draw[thick,<-,very thick] (fl) edge[bend right] (tp1);
\draw[thick,->,very thick] (tp1) edge[bend left] (tp2);
\draw[thick,<-,very thick] (tp1) edge[bend right] (tp2);
\end{tikzpicture}
\caption{Blabla...}
\label{fig:overview}
\end{figure}

Both FMI for co-simulation and FMI for model exchange are supported. 
Model exchange requires a solver in the wrapper executable.
For this reason, two solvers from the Sundials package are included.

\section{Setting up a simulation}
\label{sec:setting_up}
The FMI wrapper is started by the StartTLMFMIWrapper startup script.
This script generates the \texttt{tlm.config} fileand calls the FMIWrapper executable.
The executable takes the following arguments:\\

\noindent \verb|FMIWrapper <path> <fmufile> <solver> <debug>|\\

Example:\\

\noindent \verb|FMIWrapper C:\temp\folder mymodel.fmu solver=CVODE -d|\\

The last to arguments are optional.
Available solvers are \texttt{Euler}, \texttt{CVODE} and \texttt{IDA}.
These can currently only be changed by modifying the startup script, i.e. not from the graphical interface.

An FMU keep track of its variables by integer numbers called \texttt{value references}.
However, it does not provide any information about the mapping between its variables and the TLM interface.
Hence, this information must be provided by the user.
A configuration file called \texttt{fmi.config} is used for this purpose, see \cref{lst:fmiconfig}.

\begin{lstlisting}[basicstyle=\ttfamily,floatplacement=ht,caption=A configuration file maps value references to TLM variables,label=lst:fmiconfig]
substeps,100
name,tlm1
position,6,7,8
orientation,136,139,142,137,140,143,138,141,144
speed,9,10,11
ang_speed,145,146,147
force,133,134,135,167,168,169
name,tlm2
position,...
\end{lstlisting}

As can be seen, data is stored in a comma-separated format.
The first line specifies the number of substeps used for FMI for Co-Simulation (see \cref{sec:fmi_cs}).
After this comes the port information.
Each port is specified by name, position, orientation, speed, angular speed and force, according to the TLM interfaces in the TLM framework.
The numbers after each keyword are the value references.
These can be obtained by analyzing the \texttt{modelDescription.xml} file.
\Cref{lst:modeldescription} shows an example.
The variable first torque component has the value reference 167.
Hence, this number should be inserted as number four on the "force" line in \texttt{fmi.config}.

\begin{lstlisting}[language=XML,floatplacement=ht,caption=Value references for variables are obtained from \texttt{modelDescription.xml},label=lst:modeldescription]
  <ScalarVariable
    name="fMITLMInterface3D1.t[1]"
    valueReference="167"
    variability="continuous"
    causality="local"
    >
    <Real/>
  </ScalarVariable>
\end{lstlisting}


\section{FMI for Co-Simulation}
\label{sec:fmi_cs}
With FMI for Co-Simulation the solver is embedded within the FMU.
Variables can only be exchanged at predefined communication points.
Hence, it is not possible for the solver to obtain interpolated force variables during internal iteration steps.
Keeping the force constant during the entire communication interval may, however, have a negative effect on numerical stability.
For this reason it is possible to divide each communication interval into a fixed number of \textit{sub steps}, as defined in the \texttt{fmi.config}.
In this way the forces can at least be updated in the FMU at more fine-grained intervals.
Pseudo-code for the simulation loop in the wrapper is shown in \cref{lst:wrapper_cs}.

\lstset{emph={fmu},emphstyle={\color{red}\bfseries},
        emph={[2]TLMPlugin},emphstyle={[2]\color{blue}\bfseries}
}
\begin{lstlisting}[float, language=c++, basicstyle=\ttfamily\small,floatplacement=htb,caption=Pseudo code for the simulation loop with FMI for co-simulation,label=lst:wrapper_cs]
while (tcur < tend) {
    double hsub = hmax/nSubSteps;
    for(size_t i=0; i<nSubSteps; ++i) {
        x = fmu.get_real(x_vr,3);
        T = fmu.get_real(T_vr,9);
        v = fmu.get_real(v_vr,3);
        w = fmu.get_real(w_vr,3);
        f = TLMPlugin.GetForce(tcur,x,T,v,w);
        fmu.set_real(f_vr[j],6,f);
        
        TLMPlugin.SetMotion(tcur,x,T,v,w);

        fmu.do_step(tcur,hsub);
        tcur+=hsub;

        x = fmu.get_real(x_vr,3);
        T = fmu.get_real(T_vr,9);
        v = fmu.get_real(v_vr,3);
        w = fmu.get_real(w_vr,3);
    }
}
\end{lstlisting}

Note that it is necessary to read the motion variables from the FMU before obtaining the force from the TLMPlugin. 
At the end of each major step it is also necessary to call \texttt{GetForce()} before calling \texttt{SetMotion()}.
The reason for this is that \texttt{SetMotion()} requires updated input variables which are retreived by \texttt{GetForce()}.

\vspace{0cm}

\section{FMI for model exchange}
With model exchange, the wrapper must provide a solver for the FMU.
Three solvers are available: explicit Euler, Runge-Kutta, and the CVODE and IDA solvers from Sundials \cite{hindmarsh2005}.
\Cref{lst:wrapper_me} shows pseudo code for one major step (i.e. one communication interval) with the IDA solver.
Note that the solver is used with one step mode.
This means that it takes one step at a time, until its internal time exceeds the next communication interval.
The CVODE solver requires a callback function for obtaining derivatives of state variables (i.e. "right-hand side").
The IDA solver requires a similar callback for obtaining the residuals.

\begin{lstlisting}[float, language=c++, basicstyle=\ttfamily\small,floatplacement=ht,caption=Pseudo code for the simulation loop with FMI for model exchange,label=lst:wrapper_me]
double position[3],orientation[9],speed[3],ang_speed[3],force[6];

x = fmu.get_real(x_vr,3);
T = fmu.get_real(T_vr,9);
v = fmu.get_real(v_vr,3);
w = fmu.get_real(w_vr,3);
f = TLMPlugin.GetForce(tcur,x,T,v,w);
fmu.set_real(f_vr[j],6,f);

y = fmu.get_continuous_states();
dy = fmu.get_derivatives();

tcur += h;

while(tc < tcur){
    IDASolve(mem, tcur, &tc, y, dy, IDA_ONE_STEP);
}

fmu.set_continuous_states(y);
\end{lstlisting}

\section{Example: Double Pendulum with Dymola and OpenModelica}
This section will explain how to build a meta model of a double pendulum using FMUs exported from Dymola and OpenModelica.
\Cref{fig:double_pendulum} shows a sketch of the model.
The resulting meta model is found in the \linebreak\texttt{/MetaModels/FmuFmuPendulum} folder.
One FMU for Co-simulation and one for Model Exchange will be used.
Both models use a custom Modelica library called FMILIB for the TLM interfaces.
This library is shipped together with the FMI wrapper.

\begin{figure}[ht]
\centering
\begin{tikzpicture}
\node[draw,thick,minimum width=3cm,rectangle,rotate=-45,fill=white,xshift=1.5cm] (beam1) {};
\draw[thick,loop] (0,0) -- (0.5cm,0.5cm) -- (-0.5cm,0.5cm) -- (0,0);
\node[draw,thick,circle,minimum width=0.5cm,fill=white] () {};
\node[draw,thick,minimum width=3cm,rectangle,rotate=-30,fill=white,xshift=1.5cm] at(beam1.east) (beam2) {};
\node[draw,thick,circle,minimum width=0.5cm,fill=white] at (beam1.east) () {};

\draw[thick,dashed] (-1cm,1.5cm) -- node[below] () {Dymola} (2cm,1.5cm) -- (2cm,-0.0cm) -- (-0.0cm,-2cm) -- (-1cm,-2cm) -- (-1cm,1.5cm);

\draw[thick,dashed] (0.1cm,-2.1cm) -- (2.1cm,-0.1cm) --node[below] () {OpenModelica} (5cm,-0.1cm) -- (5.2cm,-4.1cm) -- (0.1cm,-4.1cm) -- (0.1cm,-2.1cm);
\end{tikzpicture}
\caption{A double pendulum is simulated using FMUs exported from Dymola and OpenModelica}
\label{fig:double_pendulum}
\end{figure}

The Dymola model consists of half the first pendulum and the fixed attachment to the inertial system, see figure \cref{fig:model_dymola}.
Force and torque variables must be specified as input variables at the top level of the model, in order to get the correct number of equations and variables.
Hence, we need to add the equations shown in \cref{lst:dymola_equations}.

\begin{lstlisting}[basicstyle=\small\ttfamily, floatplacement=ht,label=lst:dymola_equations,caption=Input variables must be specified on top level in the Modelica models]
  [...]
  FMITLM.FMITLM_Interface_3D.FMITLMInterface3D fMITLMInterface3D;
  input Real f[3](start = zeros(3));
  input Real t[3](start = zeros(3));
equation
  fMITLMInterface3D.f = f;
  fMITLMInterface3D3D.t = t;
  [...]
\end{lstlisting}

\begin{figure}[ht]
\centering
\includegraphics[width=0.65\textwidth]{gfx/model_dymola.png}
\caption{}
\label{fig:model_dymola}
\end{figure}

Now it is time to export the model so it can be used with the framework.
\begin{enumerate}
\item \textbf{Transform the model to an FMU for co-simulation.}\\
      Use a suitable solver, for example CVODE.
\item \textbf{Put the \texttt{.fmu} file in a new subfolder.}
\item \textbf{Create an empty text file called \texttt{fmi.config} in the same folder.}
\item \textbf{Specify number of substeps on the first line.}\\
              For example: "substeps,10"
\item \textbf{Open \texttt{modelDescription.xml}.}\\
              By opening the \texttt{.fmu} as a zip package.
\item \textbf{Locate the TLM variables and write the value references in \texttt{fmi.config}.}\\
              The desired variables are position, orientation, velocity, angular velocity, force and torque:\\
              \texttt{fMITLMInterface3D.r[x]}, \texttt{fMITLMInterface3D.A[x,y]},\\
              \texttt{fMITLMInterface3D.v[x]}, \texttt{fMITLMInterface3D.w[x]},\\
              \texttt{fMITLMInterface3D.f[x]}, \texttt{fMITLMInterface3D.t[x]}
\item \textbf{Enter the value reference for each variable in \texttt{fmi.config}.}\\
              See section \cref{sec:setting_up} for more information.              
\end{enumerate}

The OpenModelica model as shown in \cref{fig:model_omedit} consists of the second half of the first beam and the second beam.
The export process is exaclty the same as for Dymola, except that the FMU exported should be for model exchange.

\begin{figure}[ht]
\centering
\includegraphics[width=0.85\textwidth]{gfx/model_omedit.png}
\caption{The second half of the first beam and the second beam  are modelled in OpenModelica}
\label{fig:model_omedit}
\end{figure}

When both FMUs have been generated together with one \texttt{fmi.config} file each, it is time to build the meta model.
\begin{enumerate}
\item \textbf{Create a new meta model.}\\
             Either by hand or by using the graphical user interface.
\item \textbf{Add the FMUs as submodels.}\\
              Use \texttt{StartTLMFmiWrapper} as start command.
\item \textbf{Fetch TLM interfaces.}
\item \textbf{Add a connection between the two models.}\\
              Default TLM parameters should work fine.
\item \textbf{Make sure interfaces are aligned.}
\item \textbf{Choose solver for model exchange.}\\
              By editing \texttt{StartTLMFmiWrapper.bat}.\\
              Use for example \texttt{solver=CVODE} or \texttt{solver=IDA}.
\end{enumerate}

When done, the meta model XML file should look similar to \cref{lst:metamodel}.
The model is now ready to be simulated!

\begin{lstlisting}[language=xml,float,floatplacement=ht,label={lst:metamodel},caption=XML description of the complete meta model]
<?xml version='1.0' encoding='ISO-8859-1'?>
<Model Name="doublePendulum">
  <SubModels>
    <SubModel Name="doublePendulum1" 
              ModelFile="doublePendulum1.fmu"
              StartCommand="StartTLMFmiWrapper" 
              Position="0,0,0" 
              Angle321="0,0,0">
      <InterfacePoint Name="tlm" 
                      Position="0.25,0,0" 
                      Angle321="0,0,0"/>
    </SubModel>
    <SubModel Name="doublePendulum2" 
              ModelFile="doublePendulum2.fmu" 
              StartCommand="StartTLMFmiWrapper" 
              Position="0.25,0,0"  
              Angle321="0,0,0">
      <InterfacePoint Name="tlm" 
                      Position="0,0,0" 
                      Angle321="0,0,0"/>
    </SubModel>
  </SubModels>
  <Connections>
    <Connection From="doublePendulum1.tlm" 
                To="doublePendulum2.tlm" 
                Delay="1e-4" 
                Zf="10000"   
                Zfr="100"
                alpha="0.2">
    </Connection>
  </Connections>
  <SimulationParams ManagerPort="11113" StopTime="3" StartTime="0"/>
</Model>
\end{lstlisting}
%Koppla ihop modellerna
%Aligna OpenModelicas pendel till Dymolas
%Välj lösare för model exchange i StartTLMFMIWrapper.bat, t.ex. CVODE eller IDA
%Kör simuleringen!


\bibliographystyle{plain}
\bibliography{references}


\end{document}
