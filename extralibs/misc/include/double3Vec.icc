#ifndef _double3Vec_ICC
#define _double3Vec_ICC

#include <cassert>



// For repetive division it can be more efficient to create a intermediate variable
// and to do multiplication instead. Some low level tests indicate a factor 4.
// On other hand, we loose some precision. Which is most important, tests will tell.
// To activate, define these. DF 2011-04-04
#define FASTDIV          // Was activated in the past.
//#define FASTDIVX       // Was not activated in the past. 
	                 // Tried 2011-04-13, was a bit slower on test cases! Needs more investigation. DF

namespace tlmMisc
{

////////////////////////////////////////////////////////////////////////////////
//
// Definitions of member functions and global methods to class double3Vec
//

inline double3Vec::double3Vec(const double val)
: XX(val), YY(val), ZZ(val)
{}

inline double3Vec::double3Vec(const double xval,
			const double yval, 
			const double zval) 
: XX(xval), YY(yval), ZZ(zval)
{}

inline double3Vec::double3Vec(const double3Vec& val)
: XX(val.XX), YY(val.YY), ZZ(val.ZZ)
{}

inline double double3Vec::norm2() const
{
    return sqrt(XX * XX + YY * YY + ZZ * ZZ);
}

//! Return "length" of XY components of vector.
inline double double3Vec::norm2XY() const{
    return sqrt(XX * XX + YY * YY);
}


inline double3Vec& double3Vec::normalize()
{
    double mag = this->norm2();
    if (mag != 0.0) {
#ifdef FASTDIV
	mag = 1.0 / mag;
	XX *= mag;
	YY *= mag;
	ZZ *= mag;
#else
	XX /= mag;
	YY /= mag;
	ZZ /= mag;
#endif
    } 

    return *this;
}

inline double3Vec& double3Vec::normalizeSafe()
{
    double mag = this->norm2();
    if (mag != 0.0) {
#ifdef FASTDIV
	mag = 1.0 / mag;
	XX *= mag;
	YY *= mag;
	ZZ *= mag;
#else
	XX /= mag;
	YY /= mag;
	ZZ /= mag;
#endif
    } else {
	XX = 1.0;
	YY = 0.0;
	ZZ = 0.0;
    }	

    return *this;
}

inline double& double3Vec::operator()(const int i)
{
    double *x;	
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif

    switch(i) {
    case 1:
      x = &XX;
      break;	
    case 2:
      x = &YY;
      break;
    default:
      x = &ZZ;
      break;
    }

//    if (i==1) x = &XX;
//    else if (i==2) x = &YY;
//    else x = &ZZ;

    return *x; 
}


inline double double3Vec::operator()(const int i) const
{
    double x;
#ifdef DEBUGFLG
    assert(i > 0 && i <= 3);	
#endif
    switch(i) {
    case 1:
      x = XX;
      break;	
    case 2:
      x = YY;
      break;
    default:
      x = ZZ;
      break;
    }

//    if (i==1) x = XX;
//    else if (i==2) x = YY;
//    else x = ZZ;

    return x; 
}

inline double3Vec& double3Vec::operator=(const double a)
{
    XX = a;
    YY = a;
    ZZ = a;
    return *this;
}

inline double3Vec& double3Vec::operator=(const double3Vec& v)
{
    if (this != &v) {	
       XX = v.XX;
       YY = v.YY;
       ZZ = v.ZZ;
    }
    return *this;
}

inline double3Vec& double3Vec::operator+=(const double3Vec& v)
{
    XX += v.XX;
    YY += v.YY;
    ZZ += v.ZZ;
    return *this;
}

inline double3Vec& double3Vec::operator-=(const double3Vec& v)
{
    XX -= v.XX;
    YY -= v.YY;
    ZZ -= v.ZZ;
    return *this;
}

inline double3Vec& double3Vec::operator*=(const double s)
{
    XX *= s;
    YY *= s;
    ZZ *= s;
    return *this;
}

inline double3Vec& double3Vec::operator/=(const double s)
{
#ifdef FASTDIVX
    double tmp = 1.0 / s;
    XX *= tmp;
    YY *= tmp;
    ZZ *= tmp;
#else
    XX /= s;
    YY /= s;
    ZZ /= s;
#endif
    return *this;
}


inline bool double3Vec::isZero() const
{
    return (XX==0.0)&&(YY==0.0)&&(ZZ==0.0);
}

inline bool double3Vec::isNonZero() const
{
    return (XX!=0.0)||(YY!=0.0)||(ZZ!=0.0);
}

inline void double3Vec::Set(const double a1, const double a2, const double a3)
{
    XX = a1;
    YY = a2;
    ZZ = a3;
}


inline void double3Vec::Get(double& a1, double& a2, double& a3) const
{
    a1 = XX;
    a2 = YY;
    a3 = ZZ;
}





#ifdef USE_IMPLICIT_CONV
inline double3Vec::double3Vec  (const float3& conv_in){
        XX= conv_in.XX;
        YY= conv_in.YY;
        ZZ= conv_in.ZZ;
}
#endif




////////////////////////////////////////////////////////////////////////
//
// Definition of global functions related to double3Vec
//

// -V
inline const double3Vec operator-(const double3Vec& v)
{
    return double3Vec(-v.XX, -v.YY, -v.ZZ);
}

// s * V
inline const double3Vec operator*(const double s, const double3Vec& v)
{
    return double3Vec(s * v.XX, s * v.YY, s * v.ZZ);
}

// V * s
inline const double3Vec operator*(const double3Vec& v, const double s)
{
    return double3Vec(s * v.XX, s * v.YY, s * v.ZZ);
}


// V * V
inline double operator*(const double3Vec& a, const double3Vec& b)
{
    return (a.XX*b.XX + a.YY*b.YY + a.ZZ*b.ZZ);
}


// V / s
inline const double3Vec operator/(const double3Vec& v, const double s)
{
#ifdef FASTDIV
    double recip = 1.0 / s;
    return double3Vec(v.XX * recip, v.YY * recip, v.ZZ * recip);
#else
    return double3Vec(v.XX / s, v.YY / s, v.ZZ / s);
#endif
}


// V / V
inline const double3Vec operator/(const double3Vec& v, const double3Vec& w)
{
    return double3Vec(v.XX / w.XX, v.YY / w.YY, v.ZZ / w.ZZ);
}

// V + V
inline const double3Vec operator+(const double3Vec& a, const double3Vec& b)
{
    return double3Vec(a.XX + b.XX, a.YY + b.YY, a.ZZ + b.ZZ);
}

// V + s
inline const double3Vec operator+(const double3Vec& a, const double s)
{
    return double3Vec(a.XX + s, a.YY + s, a.ZZ + s);
}

// s + V
inline const double3Vec operator+(const double s, const double3Vec& a)
{
    return double3Vec(a.XX + s, a.YY + s, a.ZZ + s);
}

// V - V
inline const double3Vec operator-(const double3Vec& a, const double3Vec& b)
{
    return double3Vec(a.XX - b.XX, a.YY - b.YY, a.ZZ - b.ZZ);
}

// V - s
inline const double3Vec operator-(const double3Vec& a, const double s)
{
    return double3Vec(a.XX - s, a.YY - s, a.ZZ - s);
}

// s - V
inline const double3Vec operator-(const double s, const double3Vec& a)
{
    return double3Vec(s - a.XX, s - a.YY, s - a.ZZ);
}

// V == V (no fuzz for comparison)
inline bool operator==(const double3Vec& a, const double3Vec& b)
{
    return a.XX == b.XX && a.YY == b.YY && a.ZZ == b.ZZ;
}

// V == s (no fuzz for comparison)
inline bool operator==(const double3Vec& a, const double b)
{
    return a.XX == b && a.YY == b && a.ZZ == b;
}

// s == V (no fuzz for comparison)
inline bool operator==(const double a, const double3Vec& b)
{
    return a == b.XX && a == b.YY && a == b.ZZ;
}

// V != V (no fuzz for comparison)
inline bool operator!=(const double3Vec& a, const double3Vec& b)
{
    return !(a == b);
}


// V = Cross(V1, V2) CrossProduct, normally written V = V1 x V2
inline const double3Vec Cross(const double3Vec& V1, const double3Vec& V2)
{
    return double3Vec(V1.YY*V2.ZZ - V2.YY*V1.ZZ,
              V1.ZZ*V2.XX - V2.ZZ*V1.XX,
              V1.XX*V2.YY - V2.XX*V1.YY);
}


#if 0
inline const double3Vec sin(const double3Vec& v)
{
    return double3Vec( ::sin(v.XX), ::sin(v.YY), ::sin(v.ZZ));
}

inline const double3Vec cos(const double3Vec& v)
{
    return double3Vec( ::cos(v.XX), ::cos(v.YY), ::cos(v.ZZ));
}
#endif

}

#endif //  _double3Vec_ICC





